## Lab 3. Ray casting

Спроектувати та написати програму, що приймає на вхід файл формату wavefront obj, а на виході створює зображення певного формату з візуалізацією моделі, яка знаходиться у вхідному файлі. Аргументи програми:

- `--source` - вхідний obj файл для рендерингу;
- `--output` - шлях до зображення-результату;

Приклад виклику програми:
```
> raytracer.exe --source=cow.obj --output=rendered.ppm
```

1. Вивід фінального зображення у файл.

   Створіть інтерфейс для виводу, через який "зображення" виводиться в консоль. Створіть другу реалізацію такого інтерфейсу, яка б виводила те саме зображення в файл [формату ppm](https://en.wikipedia.org/wiki/Netpbm) або іншого, якщо ви виконали роботу №2. Результат виконання першої роботи перед виводом у консоль можна уявити як матрицю із чисел з плаваючою комою в діапазоні 0-1. Вам спочатку треба буде перетворити ці числа на кольори. Найпростіший варіант отримати сірий колір у форматі RGB – помножити отримані числа на вектор (255, 255, 255).

   Якщо вам не зручно буде постійно працювати із файлами формату ppm і ви не плануєте виконувати роботу №2, ви можете створити іншу імплементацію інтерфейсу, яка б виводила зображення у файл будь-якого іншого поширеного формату за допомогою 3rd-party бібліотеки.

   Очевидно, тепер ви можете збільшити роздільну здатність зображення до більш-менш прийнятного.

2. [Алгоритм Мьоллера-Трамбора](http://www.graphics.cornell.edu/pubs/1997/MT97.pdf)

   Перепишіть алгоритм пошуку перетину променя з трикутником на мову вашої програми. Покрийте вашу реалізацію тестами: в наступному пункті вам доведеться зчитувати багато трикутників з файлу, а в наступній роботі зберігати їх в спеціальній структурі для швидкого пошуку, тож тести допоможуть вам швидше знаходити джерело помилок (а вони у вас будуть із ймовірністю близькою до 100%).

3. Читання obj файлів.

   Ознайомтеся з [форматом obj файлів](https://uk.wikipedia.org/wiki/Obj). Зчитайте набір трикутників з файлу, вказаного через параметри командного рядка. Наразі вам знадобляться лише точки, нормалі та індекси. Докладніше цей формат розбиратиметься на лекції.

4. Матричні перетворення

   Створіть необхідні структури даних для роботи з матрицями. Додайте функції для простого створення матриць переміщення, повороту, розтягування. Функції застосування матриць до точок, векторів, нормалей, трикутників.

   Обов'язково спроектуйте можливість виконання довільної послідовність перетворень геометрії об'єкта перед початком трасування. Ця послідовність наразі має задаватися в коді вашої програми, проте згодом буде вводитися через інший файл.

   Виконайте також матричні перетворення над позицією та напрямком камери.

5. Тіні

   Це "основна"  і найпростіша частина роботи, яку доцільно виконувати лише після пунктів 1-3. Ідея доволі проста: щойно знайдено найближчий до камери перетин трасувального променя R<sub>1</sub> із об'єктом O на сцені треба створити ще один новий промінь R<sub>2</sub> із місця перетину (P) в той бік, з якого падає світло. Потім ми так само знаходимо перетин нового променя R<sub>2</sub> із об'єктами на сцені. Якщо будь-який перетин знайдено, значить на шляху між світлом і точкою P на об'єкті O є перепона, тож точка P знаходиться в тіні. Зауважте, що вам треба знайти для цього променя _будь-який_ перетин, що значно швидше за пошук _найближчого_ перетину, оскільки не потрібно перебирати всі об'єкти на сцені. Тому для ефективного рішення цієї задачі треба додати нову функцію/метод, що закінчуватиме пошук після знаходження першого ж перетину.
